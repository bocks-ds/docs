const fs = require('fs');

const env = require('env_vars');
const config = require('../docs/config')
const helpers = require('helpers')
const json_data = require('database/json_parser');

const ABCDoc = require('abc_doc')


class TablesDoc extends ABCDoc {

    constructor(source_directory) {
        let target_file = `${source_directory}/structures.rst`
        super("Structures", source_directory, target_file)
    }

    get_doc() {
        let doc = this.base_doc()
        Object.keys(env.tableSingulars).sort().forEach((table_name) => {
            let table = new Table(table_name)
            doc = `${doc}${table.output()}\n`
        })
        return doc
    }
}

class Table {
    constructor(table_name){
        this.name = table_name
        this.object_name = env.tableSingulars[table_name]
    }

    output() {
        let head = `${this._title()}\n${this._config_data()}\n\n`
        let body = `${this._base_data()}\n${this._relational_data()}\n`
        return `${head}${body}*****\n\n`
    }

    _title() {
        return `${this.name}\n${'*'.repeat(this.name.length)}\n`
    }

    _base_data() {
        output = ''
        data = json_data.table_structures[this.name]
        Object.keys(data).forEach((column) => {
            let type = data[column]
            let [info, name] = this._get_info(type, column)
            output = `${output}\n - \`\`${name}\`\` - *${info}*\n`
        })
        if (output)
            return `Columns that may be queried:${output}`
        return ''
    }

    _get_info(type, column) {
        let info = ''
        if (type.includes("string")) {
            let str_len = type.split("string")
            info = `String with a maximum length of ${str_len[1]}`
        } else if (column.includes('_id')){
            column = column.replace('_id', '')
            if (column != 'parent') {
                info = `${helpers.getModelName(column)}; `
            }
            info = `${info}References a single element from ${column != 'parent' ? column : 'this table'}`
        } else if (type == 'Int' || type == 'number' || 'ID') {
            info = 'Number'
        } else {
            info = type.charAt(0).toUpperCase() + type.slice(1)
        }
        return [info, column]
    }

    _config_data() {
        return config.Structures.entries[this.name] || ''
    }

    _relational_data() {
        let output = ''
        let tables = env.associativeTables
        Object.keys(tables).forEach((table_name) => {
            if(tables[table_name].supported_tables.includes(this.name)) {
                let source = tables[table_name].junction_target ? tables[table_name].junction_target : table_name
                let singular = helpers.getModelName(source)
                let source_msg = ''
                if (source != table_name)
                    source_msg = `\`\`${source}\`\` *table; Resolved via ${table_name}*`
                else
                    source_msg = `\`\`${source}\`\``
                if (source != this.name)
                    output = `${output}\n  - \`\`${table_name}\`\` - *${singular}; Entry from* ${source_msg}\n`
            }
        })
        if (output)
            return `Relationships that may be queried:${output}\n`
        return ''
    }
}

module.exports = TablesDoc